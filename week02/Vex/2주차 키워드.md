## 🖥️ 정규화

> 정의
> 
- 데이터를 효율적으로 저장하기 위한 중복 제거 및 데이터 일관성 있게 유지하는 것입니다.

>💡
일관성?  
데이터 일관성은 데이터베이스의 모든 데이터가 통일된 상태를 유지해야 것을 말합니다.
예를 들면, 고객의 이름이 여러 테이블에 저장되어 있을 때 모든 테이블에서 사용하는 고객 이름 정보는 동일해야합니다.
이러한 일관성을 깨뜨리는 가장 큰 원인은 바로 중복성과 **불필요한 종속성**입니다.

## ❌ 이상현상

### 삽입 이상

데이터를 삽입할 때, 원치 않는 다른 정보까지 함께 삽입해야 하거나 아예 삽입 자체가 불가능해지는 문제를 말합니다.

이 테이블은 직원이 어떤 부서에 소속되어 있는지와 그 부서의 위치 정보를 함께 저장하고 있습니다.

| `직원ID` | `직원이름` | `부서ID` | `부서명` | `부서위치` |
| --- | --- | --- | --- | --- |
| 101 | 김민준 | HR01 | 인사부 | 서울 |
| 102 | 최아라 | DEV02 | 개발팀 | 판교 |


> 💡
### 해당 테이블에 새로운 부서를 추가한다면?   
직원을 추가 하기 위해서는 부서ID와 부서명도 컬럼의 데이터도 반드시 있어야 합니다.  
하지만, 여기서 새로운 ‘**마케팅**’ 팀을 만들어둔다고 하면 반드시 해당 팀에 들어갈 직원 데이터가 있어야합니다.  
이렇게 되면 새로운 부서 데이터를 넣을 때 넣을 수 없는 **이상 현상이 발생**하게 됩니다.  


### 삭제 이상

데이터를 삭제하였는데, 다른 인스턴스나 테이블에 해당 데이터가 남아 있거나 완전히 삭제될 경우

> 💡  
예를 들어볼까요?

| `직원ID` | `직원이름` | `프로젝트ID` | `프로젝트이름` | `담당매니저` |
| --- | --- | --- | --- | --- |
| 101 | 김민준 | P-001 | 웹 개발 | 이지훈 |
| 102 | 최아라 | P-002 | 앱 디자인 | 박서연 |
| 103 | 최민호 | P-003 | 데이터 분석 | 박서연 |

> 위 테이블에서 직원ID ‘103’번인 최민호씨를 삭제해보겠습니다.  
하지만 테이블이 위 하나의 테이블만 있을 때 최민호씨를 삭제하면 최민호라는 이름만 삭제될까요?  
그와 같은 행에 있는 프로젝트 관련 데이터 및 담당 매니저 데이터가 모두 데이터베이스 상에서 사라지게 됩니다.  

이렇게 삭제할 하나의 데이터를 데이터베이스 상에서 제거했을 때, 그와 연관되지 않은 다른 데이터들이 삭제될 경우를 삭제 이상 현상이 발생했다고 합니다!

### 갱신(수정) 이상

데이터가 변경되어 수정하였는데, 다른 테이블에 데이터와 일관성이 붕괴될 경우

아래에서 이와 비슷한 예가 있습니다!

## ✅ 정규화의 단계

### 1️⃣ 제1정규화

각 행의 인스턴스가 다중값을 가지고 있을 경우 실행한다.

> 제1정규형을 만족하지 못한 테이블
> 

| `학생ID` | `학생이름` | `전공` | `수강과목` |
| --- | --- | --- | --- |
| 101 | 김민준 | 컴퓨터공학 | 데이터베이스, 운영체제 |
| 102 | 이서연 | 디자인학 | 시각디자인, UI/UX개론 |

> 제1정규형을 만족한 테이블
> 

| `학생ID` | `학생이름` | `전공` | `수강과목` |
| --- | --- | --- | --- |
| 101 | 김민준 | 컴퓨터공학 | 데이터베이스 |
| 101 | 김민준 | 컴퓨터공학 | 운영체제 |
| 102 | 이서연 | 디자인학 | 시각디자인 |
| 102 | 이서연 | 디자인학 | UI/UX개론 |

### 2️⃣ 제2정규화

제1정규형을 만족하고 `composite primary key` 에 종속되어 있는 컬럼이 있는 테이블에 실행

> 제2정규형을 만족하지 못한 테이블
> 

| `주문번호` (PK) | `상품번호` (PK) | `상품명` | `주문수량` |
| --- | --- | --- | --- |
| 001 | A123 | 책상 | 1 |
| 001 | B456 | 의자 | 2 |
| 002 | A123 | 책상 | 1 |

> 제2정규형을 만족한 테이블들
> 

주문

| `주문번호` (PK) | `상품번호` (PK) | `주문수량` |
| --- | --- | --- |
| 001 | A123 | 1 |
| 001 | B456 | 2 |
| 002 | A123 | 1 |

상품

| `상품번호` (PK) | `상품명` |
| --- | --- |
| A123 | 책상 |
| B456 | 의자 |

<aside>
💡

왜 제2정규화를 해야할까?

제2정규화를 만족하지 않은 테이블을 한 번 살펴보면

| `주문번호` (PK) | `상품번호` (PK) | `상품명` | `주문수량` |
| --- | --- | --- | --- |
| 001 | A123 | 책상 | 1 |
| 001 | B456 | 의자 | 2 |
| 002 | A123 | 책상 | 1 |

현재 `상품명` 컬럼이 `상품번호` 컬럼에 종속되어 있는 상태입니다.

여기서, 현재 A123 이라는 상품 번호를 가진 책상이 침대와 같은 다른 제품으로 변경된다면 해당하는 상품번호를 전부 찾아 **책상 → 침대**로 변경 해야 합니다.

주문

| `주문번호` (PK) | `상품번호` (PK) | `주문수량` |
| --- | --- | --- |
| 001 | A123 | 1 |
| 001 | B456 | 2 |
| 002 | A123 | 1 |

상품

| `상품번호` (PK) | `상품명` |
| --- | --- |
| A123 | 책상 |
| B456 | 의자 |

하지만, 위처럼 제2정규화를 해두면 상품 테이블의 데이터 하나만 수정하는걸로 그와 관련된 테이블의 데이터까지 수정되는 효과를 가질 수 있습니다! 와!

</aside>

### 3️⃣ 제3정규화

제2정규형을 만족하고, 기본키 외 다른 컬럼에 종속되어 있는 컬럼이 있을 경우 진행

> 제3정규형을 만족하지 못한 테이블
> 

| `학생번호` (PK) | `학생이름` | `학과번호` | `학과명` |
| --- | --- | --- | --- |
| 2021001 | 박서준 | CS01 | 컴퓨터공학 |
| 2021002 | 최유진 | DS02 | 데이터사이언스 |
| 2021003 | 김민아 | CS01 | 컴퓨터공학 |
- 위 테이블 보시면 `학과번호` 컬럼에 `학과명` 컬럼이 종속되어 있는 것을 알 수 있습니다.
- 아까, 제2정규화를 해야 하는 이유에서 보셨다시피 이 테이블도 동일하게 하나의 학과가 수정되면 그와 같은 학과번호를 가진 인스턴스들을 모두 수정해야 합니다.

> 제3정규형을 만족한 테이블
> 

학생

| `학생번호` (PK) | `학생이름` | `학과번호` |
| --- | --- | --- |
| 2021001 | 박서준 | CS01 |
| 2021002 | 최유진 | DS02 |
| 2021003 | 김민아 | CS01 |

학과

| `학과번호` (PK) | `학과명` |
| --- | --- |
| CS01 | 컴퓨터공학 |
| DS02 | 데이터사이언스 |
- 위처럼 제3정규화를 통해 정규화를 실행하면 데이터가 수정되어도,
하나의 인스터스만 수정하면 다른 연관된 인스턴스들도 수정되는 효과를 가질 수 있습니다! 우왕!

### 📌 참고 영상

https://www.youtube.com/watch?v=Y1FbowQRcmI

- 인덱스(Index)
    
    
    ## ✅ 인덱스?
    
    인덱스란, 데이터를 빨리 찾기 위한 주소값을 저장해두는 것이라고 생각합니다.
    
    예를 들면, 사용자의 주민등록번호 정보를 찾을 때 이러한 인덱스가 없다면 모든 데이터를 하나하나 찾아가면서 찾으려는 데이터와 비교해야할 것입니다!
    
    마치 `Sequential Binary` [이진 탐색(Binary Search)](https://www.notion.so/Binary-Search-e983149fecf0476d949ce646988d61a0?pvs=21) 처럼요!
    
    하지만, 고유한 주소값을 저장해두면 어떨까요?
    
    찾으려는 데이터의 주소값만 알면 더욱 빠르게 데이터를 찾아올 수 있겠죠!
    
    ### 🧩 장점
    
    1. 속도: 쿼리 속도를 획기적으로 향상시킨다!
        1. `SELECT` `GROUP BY` `ORDER BY` `WHERE` 등의 처리 속도 향상
    
    ### ❌ 단점
    
    1. 추가 저장 공간: 고유한 인덱스를 추가 해야하는 만큼 데이터의 크기에 따라 차지하는 디스크 공간도 많아진다!
    
- ORM VS Raw SQL
    
    
    ## 🖥️ ORM
    
    - 프로그래밍 언어의 객체와 관계형 데이터베이스의 테이블을 자동으로 매핑!
    - 데이터베이스 외에 백엔드나 프론트엔드를 공부하셨다면 더 익숙하실 문법들로 이루어짐!
    
    ### 🧩 장점
    
    1. 보안: 데이터를 가져올 때 한번 필터를 거쳐서 가져오기 때문에 보안 위험이 적다!
    2. 독립성: 데이터베이스를 변경하더라도 코드 수정을 최소화할 수 있다.
    
    ### ❌ 단점
    
    1. 유연성: 복잡한 쿼리를 작성할 때, 해당 기능을 제공하지 않을 경우 대처할 방안이 적다.
    2. 성능: 복잡한 쿼리문을 작성할 때, 예기치 못한 성능 오버헤드가 발생할 수 있다.
    
    ---
    
    ## 📈 Raw SQL
    
    - 개발자가 직접 데이터베이스에 명령을 내리는 쿼리 문법 그 자체
    - 데이터베이스 쿼리문에서 사용하는 `SELECT ~ FROM` 쿼리문이 바로 Raw SQL
    
    ### 🧩 장점
    
    1. 유연성: 대부분의 쿼리문을 직접 작성하기 때문에 상황에 맞는 쿼리문을 작성할 수 있다.
    2. 성능: 쿼리문을 직접 짜며 최적화를 하기 때문에 성능 오버헤드가 발생할 확률이 적다.
    
    ### ❌ 단점
    
    1. 보안: 데이터베이스에 바로 데이터를 요청하기 때문에 보안 위험이 있다!
    2. 독립성: 데이터베이스를 변경해야할 경우 쿼리문을 모두 수정해야한다.